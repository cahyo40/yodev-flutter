/// Template version tracking for yo.dart generator
///
/// Tracks which template version was used to generate each file,
/// enabling detection of outdated generated files and selective
/// regeneration when templates are updated.
library;

// ignore_for_file: avoid_classes_with_only_static_members

class TemplateVersion {
  /// Current template versions for each generator type
  static const Map<String, String> current = {
    // Core templates
    'page': '1.0.0',
    'model': '1.0.0',
    'entity': '1.0.0',
    'controller': '1.0.0',
    'datasource': '1.0.0',
    'repository': '1.0.0',
    'usecase': '1.0.0',
    'screen': '1.0.0',
    'dialog': '1.0.0',
    'widget': '1.0.0',
    'service': '1.0.0',

    // Infrastructure templates
    'network': '1.0.0',
    'di': '1.0.0',
    'router': '1.0.0',
    'theme': '1.0.0',
    'l10n': '1.0.0',
    'main': '1.0.0',

    // Test templates
    'test_unit': '1.0.0',
    'test_widget': '1.0.0',
    'test_provider': '1.0.0',
  };

  /// Generate the version header comment for a generated file
  static String header(String templateType) {
    final version = current[templateType] ?? '1.0.0';
    return '// Generated by yo.dart v$version - DO NOT MODIFY BY HAND\n'
        '// Template: $templateType@$version\n';
  }

  /// Check if a file was generated by yo.dart and extract version info
  static TemplateInfo? extractInfo(String fileContent) {
    final versionMatch = RegExp(
      r'// Generated by yo\.dart v(\d+\.\d+\.\d+)',
    ).firstMatch(fileContent);

    final templateMatch = RegExp(
      r'// Template: (\w+)@(\d+\.\d+\.\d+)',
    ).firstMatch(fileContent);

    if (versionMatch == null || templateMatch == null) return null;

    return TemplateInfo(
      generatorVersion: versionMatch.group(1)!,
      templateType: templateMatch.group(1)!,
      templateVersion: templateMatch.group(2)!,
    );
  }

  /// Check if a generated file is outdated
  static bool isOutdated(String fileContent) {
    final info = extractInfo(fileContent);
    if (info == null) return false;

    final currentVersion = current[info.templateType];
    if (currentVersion == null) return false;

    return _compareVersions(info.templateVersion, currentVersion) < 0;
  }

  /// Compare two semantic versions
  /// Returns negative if a < b, 0 if equal, positive if a > b
  static int _compareVersions(String a, String b) {
    final aParts = a.split('.').map(int.parse).toList();
    final bParts = b.split('.').map(int.parse).toList();

    for (var i = 0; i < 3; i++) {
      final diff = aParts[i] - bParts[i];
      if (diff != 0) return diff;
    }
    return 0;
  }
}

/// Information extracted from a generated file's header
class TemplateInfo {
  TemplateInfo({
    required this.generatorVersion,
    required this.templateType,
    required this.templateVersion,
  });
  final String generatorVersion;
  final String templateType;
  final String templateVersion;

  /// Check if this template is up to date
  bool get isUpToDate {
    final current = TemplateVersion.current[templateType];
    if (current == null) return true;
    return templateVersion == current;
  }

  @override
  String toString() =>
      'Template: $templateType@$templateVersion (generator v$generatorVersion)';
}
